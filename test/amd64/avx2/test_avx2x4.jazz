from Keccak require "avx2/keccak1600x4_fixedsizes.jinc"
from Keccak require "avx2/keccak1600x4_updstate.jinc"

param int RATE8 = R168;
param int TRAIL = SHAKE;

param int SIZE = RATE8+15; // 183
param int REPS = RATE8/15; // 11

param int BIGSIZE = SIZE*(REPS+1); // 2196

export fn get_params_avx2x4
( reg mut ptr u64[4] params
) -> reg ptr u64[4]  /* params */
{
  params[0] = RATE8;
  params[1] = TRAIL;
  params[2] = SIZE;
  params[3] = BIGSIZE;
  return params;
}

export fn init_state_avx2x4
( reg mut ptr u256[25] state
) -> reg ptr u256[25]
{
  state = __state_init_avx2x4(state);
  return state;
}

export fn unpack_updstate_avx2x4
( reg mut ptr u64[26] st0 st1 st2 st3
, reg const ptr keccakx4_updstate st4x
) -> reg ptr u64[26]
   , reg ptr u64[26]
   , reg ptr u64[26]
   , reg ptr u64[26]
{
  reg u64 ststatus;
  st4x = st4x;
  st0[0:25], st1[0:25], st2[0:25], st3[0:25] = __st4x_unpack(st0[0:25], st1[0:25], st2[0:25], st3[0:25], st4x[:u256 0:25]);
  ststatus = st4x[:u64 4*25];
  st0[25] = ststatus;
  st1[25] = ststatus;
  st2[25] = ststatus;
  st3[25] = ststatus;
  return st0, st1, st2, st3;
}

namespace TEST_AT {

  param int _ASIZE = SIZE;

  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"

    export fn absorb_bcast_avx2x4
    ( reg mut ptr u256[25] state
    , reg const ptr u8[BIGSIZE] buf
    ) -> reg ptr u256[25] /* st */
    {
      inline int i, AT;
      reg ptr u8[_ASIZE] b;

      state = state;
      buf = buf;
      AT = 0;
      for i = 0 to BIGSIZE/SIZE-1 {
	b = buf[i*_ASIZE:_ASIZE];
	state, AT = __absorb_bcast_avx2x4(state, AT, b, 0, RATE8);
      }
      b = buf[(BIGSIZE/SIZE-1)*_ASIZE:_ASIZE];
      state, AT = __absorb_bcast_avx2x4(state, AT, b, TRAIL, RATE8);
      return state;
    }

    export fn absorb_avx2x4
    ( reg mut ptr u256[25] state
    , reg const ptr u8[BIGSIZE] buf0 buf1 buf2 buf3
    ) -> reg ptr u256[25] /* st */
    {
      inline int i, AT;
      reg ptr u8[_ASIZE] b0, b1, b2, b3;

      state = state;
      buf0 = buf0;
      buf1 = buf1;
      buf2 = buf2;
      buf3 = buf3;
      AT = 0;
      for i = 0 to BIGSIZE/SIZE-1 {
	b0 = buf0[i*_ASIZE:_ASIZE];
	b1 = buf1[i*_ASIZE:_ASIZE];
	b2 = buf2[i*_ASIZE:_ASIZE];
	b3 = buf3[i*_ASIZE:_ASIZE];
	state, AT = __absorb_avx2x4(state, AT, b0, b1, b2, b3, 0, RATE8);
      }
      b0 = buf0[(BIGSIZE/SIZE-1)*_ASIZE:_ASIZE];
      b1 = buf1[(BIGSIZE/SIZE-1)*_ASIZE:_ASIZE];
      b2 = buf2[(BIGSIZE/SIZE-1)*_ASIZE:_ASIZE];
      b3 = buf3[(BIGSIZE/SIZE-1)*_ASIZE:_ASIZE];
      state, AT = __absorb_avx2x4(state, AT, b0, b1, b2, b3, TRAIL, RATE8);
      return state;
    }
}

namespace TEST_ONESHOT {

  param int _ASIZE = BIGSIZE;

  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"

  export fn absorb_avx2x4
  ( reg mut ptr u256[25] state
  , reg const ptr u8[_ASIZE] buf0 buf1 buf2 buf3
  ) -> reg ptr u256[25] /* st */
  {
    state = state; buf0 = buf0; buf1 = buf1; buf2 = buf2; buf3 = buf3;
    state, _ = __absorb_avx2x4(state, 0, buf0, buf1, buf2, buf3, TRAIL, RATE8);
    return state;
  }

  export fn squeeze_avx2x4
  ( reg mut ptr u256[25] state
  , reg mut ptr u8[_ASIZE] buf0 buf1 buf2 buf3
  ) -> reg ptr u256[25]   /* st */
     , reg ptr u8[_ASIZE] /* buf0 */
     , reg ptr u8[_ASIZE] /* buf1 */
     , reg ptr u8[_ASIZE] /* buf2 */
     , reg ptr u8[_ASIZE] /* buf3 */
  {
    state = state; buf0 = buf0; buf1 = buf1; buf2 = buf2; buf3 = buf3;
    state, buf0, buf1, buf2, buf3 = __squeeze_avx2x4(state, buf0, buf1, buf2, buf3, RATE8);
    return state, buf0, buf1, buf2, buf3;
  }

}

from Keccak require "avx2/keccak1600x4_updstate.jinc"

namespace TEST_UPD {

  param int _ASIZE = SIZE;

  from Keccak require "avx2/keccak1600x4_updstate_ASIZE.jinc"

}
