from Keccak require "avx2/keccak1600x4_fixedsizes.jinc"

param int RATE8 = R168;
param int TRAIL = SHAKE;

param int SIZE = RATE8+15; // 183
param int REPS = RATE8/15; // 11

param int BIGSIZE = SIZE*(REPS+1); // 2196

export fn get_params_avx2x4
( reg mut ptr u64[4] params
) -> reg ptr u64[4]  /* params */
{
  params[0] = RATE8;
  params[1] = TRAIL;
  params[2] = SIZE;
  params[3] = BIGSIZE;
  return params;
}

export fn init_state_avx2x4
( reg mut ptr u256[25] state
) -> reg ptr u256[25]
{
  state = __state_init_avx2x4(state);
  return state;
}

namespace TEST_AT {

  param int ASIZE = SIZE;

  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"

    export fn absorb_bcast_avx2x4
    ( reg mut ptr u256[25] state
    , reg const ptr u8[BIGSIZE] buf
    ) -> reg ptr u256[25] /* st */
    {
      inline int i, AT;
      reg ptr u8[ASIZE] b;

      state = state;
      buf = buf;
      AT = 0;
      for i = 0 to BIGSIZE/SIZE-1 {
	b = buf[i*ASIZE:ASIZE];
	state, AT = __absorb_bcast_avx2x4(state, AT, b, 0);
      }
      b = buf[(BIGSIZE/SIZE-1)*ASIZE:ASIZE];
      state, AT = __absorb_bcast_avx2x4(state, AT, b, TRAIL);
      return state;
    }

    export fn absorb_avx2x4
    ( reg mut ptr u256[25] state
    , reg const ptr u8[BIGSIZE] buf0 buf1 buf2 buf3
    ) -> reg ptr u256[25] /* st */
    {
      inline int i, AT;
      reg ptr u8[ASIZE] b0, b1, b2, b3;

      state = state;
      buf0 = buf0;
      buf1 = buf1;
      buf2 = buf2;
      buf3 = buf3;
      AT = 0;
      for i = 0 to BIGSIZE/SIZE-1 {
	b0 = buf0[i*ASIZE:ASIZE];
	b1 = buf1[i*ASIZE:ASIZE];
	b2 = buf2[i*ASIZE:ASIZE];
	b3 = buf3[i*ASIZE:ASIZE];
	state, AT = __absorb_avx2x4(state, AT, b0, b1, b2, b3, 0);
      }
      b0 = buf0[(BIGSIZE/SIZE-1)*ASIZE:ASIZE];
      b1 = buf1[(BIGSIZE/SIZE-1)*ASIZE:ASIZE];
      b2 = buf2[(BIGSIZE/SIZE-1)*ASIZE:ASIZE];
      b3 = buf3[(BIGSIZE/SIZE-1)*ASIZE:ASIZE];
      state, AT = __absorb_avx2x4(state, AT, b0, b1, b2, b3, TRAIL);
      return state;
    }
}

namespace TEST_ONESHOT {

  param int ASIZE = BIGSIZE;

  from Keccak require "avx2/keccak1600x4_fixedsizes_ASIZE.jinc"

  export fn absorb_avx2x4
  ( reg mut ptr u256[25] state
  , reg const ptr u8[ASIZE] buf0 buf1 buf2 buf3
  ) -> reg ptr u256[25] /* st */
  {
    state = state; buf0 = buf0; buf1 = buf1; buf2 = buf2; buf3 = buf3;
    state, _ = __absorb_avx2x4(state, 0, buf0, buf1, buf2, buf3, TRAIL);
    return state;
  }

  export fn squeeze_avx2x4
  ( reg mut ptr u8[ASIZE] buf0 buf1 buf2 buf3
  , reg mut ptr u256[25] state
  ) -> reg ptr u8[ASIZE] /* buf0 */
     , reg ptr u8[ASIZE] /* buf1 */
     , reg ptr u8[ASIZE] /* buf2 */
     , reg ptr u8[ASIZE] /* buf3 */
     , reg ptr u256[25]   /* st */
  {
    state = state; buf0 = buf0; buf1 = buf1; buf2 = buf2; buf3 = buf3;
    buf0, buf1, buf2, buf3, state = __squeeze_avx2x4(buf0, buf1, buf2, buf3, state);
    return buf0, buf1, buf2, buf3, state;
  }

}

from Keccak require "avx2/keccak1600x4_updstate.jinc"

namespace TEST_UPD {

  param int ASIZE = SIZE;

  from Keccak require "avx2/keccak1600x4_updstate_ASIZE.jinc"

}
