require "select_bmi1.jinc"
require "../common/keccak1600_generic.jinc"
require "keccak1600.jinc"

namespace A32 {
  param int _ASIZE = 32;
  require "keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A1184 {
  param int _ASIZE = 1184;
  require "keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A128 {
  param int _ASIZE = 128;
  require "keccak1600_fixedsizes_ASIZE.jinc"
}

namespace A1 {
  param int _ASIZE =  1;
  require "keccak1600_fixedsizes_ASIZE.jinc"
}

export fn _sha3_256A_A1184
( reg mut ptr u8[32] out
, reg ptr u8[1184] in
) -> reg ptr u8[32]
{ stack u64[25] st_s;
  reg ptr u64[25] st;

 () = #spill(out);
   st = st_s;
  st = __state_init_ref(st);
  st, _ = A1184::__absorb_ref(st, 0, in, SHA3, R136);
  () = #unspill(out);
  _ , out = A32::__squeeze_ref(st,out, R136);
  return out;
}

fn _shake256_A128__A32_A1
( reg mut ptr u8[128] out
, reg const ptr u8[32] seed
, reg const ptr u8[1] nonce
) -> reg ptr u8[128]
{ stack u64[25] st_s;
  reg ptr u64[25] st;
   () = #spill(out);
   st = st_s;
  st = __state_init_ref(st);
  st, _ = A32::__absorb_ref(st, 0, seed, UNFINISHED, R136);
  st, _ = A1::__absorb_ref(st, 32, nonce, SHAKE, R136);
  () = #unspill(out);
  _, out = A128::__squeeze_ref(st, out, R136);
  return out;
}
/*
export fn test_absorb1234(reg mut ptr u64[25] st, reg u64 in) -> reg ptr u64[25] {
  st = __state_init_ref(st);
  st, _, _ = __absorb_imem_ref(st, 0, in, 1234, R136, SHA3);
  return st;
}

export fn test_squeeze1234(reg mut ptr u64[25] st, reg u64 out) -> reg ptr u64[25] {
  out, st = __squeeze_imem_ref(out, 1234, st, R136);
  return st;
}*/


