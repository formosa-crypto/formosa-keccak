require "keccak1600_bmi1.jinc"



// TODO: make r8/at u64 (they are used in indexes)

/**
 Last u64 word of keccak1600_updstate is filled with:
  - byte[0] - at_position (0 <= at <= 200)
  - byte[1] - (256-c8), where c8 is capacity in bytes ( 0 < c8 <= 128 )
  - byte[2] - Trail Byte
*/

type keccak1600_incstate = u64[26];

fn _init_incstate_ref
( reg mut ptr keccak1600_incstate st
, reg u8 r64 // 9 <= r64 < 25 
, reg u8 trailb // 0 <= trailb < 256
) -> reg ptr keccak1600_incstate /* st */
{
  reg ui64 i;
  reg u64 c, t;
  r64 <<= 3;
  r64 -= 200;
  c = (64u) r64;
  t = (64u) trailb;
  t <<= 8;
  t += c;
  t <<= 8;
  i = 0;
  while (i < 25) { st[i] = 0; i += 1; }
  st[25] = t;
  return st;
}

/**
 When we read the update-data from the state (r8 and at-position), we guarantee
 that it is wellformed, that is:
  - rate in bytes (r8):  0 < r8 < 200  &&  r8 %| 8
  - at-position (at):  0 <= at < r8
 This would allow to establish safety independently of the given state.
*/
inline fn __r8_at
( reg u64 ststatus
) -> reg ui8 /* r8 ; 72 <= r8 <= 200  */
   , reg ui8 /* at  ; 0 <= at < r8 */
/* ensures:
    r8 |% 8
    0 < r8 < 200
    0 <= at < r8  */
{
 reg u64 r8, at, t;
 reg ui8 r8_ui8 at_ui8;
 at = ststatus;
 r8 = at;
 r8 >>= 8;
 r8 |= 128; // ensures c8 is negative
 at &= 255; // 0 <= at < 256
 r8 += 200;
 r8 &= 0b11111000; // ensures r8 %| 8 & r8 < 200

 t = 0;
 r8 = t if r8 <= at; // if ( r8 <= at ) { at=0; }

 r8_ui8 = (8ui) (8u) r8;
 at_ui8 = (8ui) (8u) at;
 return r8_ui8, at_ui8;
}

inline fn __trailbyte
( reg u64 ststatus
) -> reg u8
{
  reg u8 tb;

  ststatus >>= 2*8;
  tb = (8u) ststatus;
  return tb;
}

param int LEN = 1000;

inline fn aread_subu64
( reg const ptr u8[LEN] a
, reg ui64 off 
, reg ui8 len // off + len <= LEN
) -> reg ui64 /* off */
   , reg u64  /* data */
{
  reg u64 w, x;
  reg u8 sh;
  reg bool zf;

  if (len >= 8) {
    w = a.[:u64 off];
    off += 8;
  } else {
    _, _, _, _, zf = #TEST_8((8u)len, 4);
    if (!zf) {
      w = (64u) a.[:u32 off];
      off += 4;
      sh = 32;
    } else {
      w = 0;
      sh = 0;
    }
    _, _, _, _, zf = #TEST_8((8u)len, 2);
    if (!zf) {
      x = (64u) a.[:u16 off];
      x <<= (sh & 63);
      w += x;
      off += 2;
      sh += 16;
    }
    _, _, _, _, zf = #TEST_8((8u)len, 1);
    if (!zf) {
      x = (64u) a.[:u8 off];
      x <<= (sh & 63);
      w += x;
      off += 1;
    }
  }
  return off, w;
}

inline fn awrite_subu64
( reg mut ptr u8[LEN] buf
, reg ui64 off
, reg u64 data
, reg ui8 len // off + len <= LEN
) -> reg ui64        /* off */
   , reg ptr u8[LEN] /* buf */
{
  reg bool zf;

  if (len >= 8) {
    buf.[:u64 off] = data;
    off += 8;
  } else {
    _, _, _, _, zf = #TEST_8((8u)len, 4);
    if (!zf) {
      buf.[:u32 off] = (32u) data;
      off += 4;
      data >>= 32;
    }
    _, _, _, _, zf = #TEST_8((8u)len, 2);
    if (!zf) {
      buf.[:u16 off] = (16u) data;
      off += 2;
      data >>= 16;
    }
    _, _, _, _, zf = #TEST_8((8u)len, 1);
    if (!zf) {
      buf.[:u8 off] = (8u) data;
      off += 1;
    }
  }
  return off, buf;
}

inline fn _add_incarray
( reg mut ptr keccak1600_incstate st
, reg ui8 at
, reg const ptr u8[LEN] buf // at+LEN <= r8
, reg ui64 off    // off + upto - at <= LEN
, reg ui8 upto    // at <= upto <= r8
) -> reg ui8  /* at */
   , reg ui64 /* off */
   , reg ptr keccak1600_incstate /* st */
{
  reg ui8 at8, newat, len, upto8;
  reg u64 t64, at_64;
  reg ui64 off2;

  at8 = (8ui) at;
  at8 = (8ui) ((8u) at8 & 0x07); // byte position in stword

  if (at8 != 0) { // needs to fill first word...
    len = upto;
    len -= (8ui) (8u) at; // len = upto-at (bytes to process)
    at >>= 3; at <<= 3; // at = 8*(at/8) (start of stword)
    off2, t64 = aread_subu64(buf, off, len);
    len = len + at8; // bytes from the start of word
    if (len >= 8) { // need to proccess more stwords...
      off += 8;
      at_64 = (64u) (8u) at8;
      off -= (64ui) at_64; // off += (8-at8)
      at += 8;    // start of next stword
    } else { // this is the only affected stword
      off = off2; // 
      at = upto;  // its done!
    }
    at8 <<= 3;   // bits to shift...
    at8 = at8;
    t64 <<= ((8u) at8 & 63);
    at_64 = (64u) (8u) at;
    st.[at_64] ^= t64;
  }

  // now: at%8==0 || at==upto
  newat = at;
  while
    { newat += 8; }
  ( newat <= upto )
    {
      t64 = buf.[:u64 off];
      at_64 = (64u) (8u) at;
      st.[at_64] ^= t64;
      at = newat;
      off += 8;
    }

  // leftovers...
  if (at < upto) {
    upto8 = upto;
    upto8 = (8ui) ((8u) upto8 & 0x07);
    off, t64 = aread_subu64(buf, off, upto8);
    at_64 = (64u) (8u) at;
    st.[at_64] ^= t64;
  }
  
  at = upto;
  return at, off, st;
}

inline fn __update_incarray_ref
( reg mut ptr keccak1600_incstate st
, reg const ptr u8[LEN] buf
) -> reg ptr keccak1600_incstate /* st */
{
  reg u64 ststatus;
  reg ui8 r8 at upto;
  reg ui64 off;

  ststatus = st[25];
  r8, at = __r8_at(ststatus); // 0 < r8 < 200; r8 |% 8; 0 <= at <= r8

  off = 0;
  upto = LEN;
  upto += at;
  while (r8 <= upto) {
    at, off, st = _add_incarray(st, at, buf, off, r8);
    () = #spill(r8, at, upto, off, buf);
    st[0:25] = _keccakf1600_ref_(st[0:25]);
    () = #unspill(r8, at, upto, off, buf);
    upto -= r8;
    at = 0;
  }
  upto = upto;
  at, _, st = _add_incarray(st, at, buf, off, upto);
  st.[:u8 8*25] = (8u) at;

  return st;
}

inline fn __finish_incarray_ref
( reg mut ptr keccak1600_incstate st
) -> reg ptr keccak1600_incstate /* st */
{
  reg u64 ststatus;
  reg ui64 at_64, r8_64;
  reg ui8 r8, at;
  reg u8 trailb;
  ststatus = st[25];
  r8, at = __r8_at(ststatus);
  trailb = __trailbyte(ststatus);
  at_64 = (64ui) (64u) (8u) at;
  r8_64 = (64ui) (64u) (8u) r8;
  st.[:u8 at_64] ^= trailb;
  st.[:u8 r8_64-1] ^= 0x80;
  st.[:u32 8*25] &= 0xFF00FF00; // clear trail-byte and at-position
  
  return st;
}

fn _dump_incarray
( reg mut ptr u8[LEN] buf
, reg const ptr keccak1600_incstate st
, reg ui8 at      // at+LEN <= r8
, reg ui64 off    // off + upto - at <= LEN
, reg ui8 upto    // at <= upto <= r8
) -> reg ui8         /* at */
   , reg ui64        /* off */
   , reg ptr u8[LEN] /* buf */
{
  reg ui8 at8, newat, len, upto8;
  reg u64 t64, at_64;

  at8 = (8ui) at;
  at8 = (8ui) ((8u) at8 & 0x07); // byte position in stword

  if (at8 != 0) { // needs to dump remainder of first word...
    len = upto;
    len -= (8ui) (8u) at; // len = upto-at (bytes to process)
    at >>= 3; at <<= 3; // at = 8*(at/8) (start of stword)
    at8 <<= 3;   // bits to shift...
    at_64 = (64u) (8u) at;
    t64 = st.[at_64];
    at8 = at8;
//    t64 >>= (8u) at8;
    off, buf = awrite_subu64(buf, off, t64, len);
    len = len + at8; // bytes from the start of word
    if (len >= 8) {  // need to proccess more stwords...
      at += 8;       // start of next stword
    } else {         // this is the only affected stword
      at = upto;     // its done!
    }
  }

  // now: at%8==0 || at==upto
  newat = at;
  while
    { newat += 8; }
  ( newat <= upto )
    {
      at_64 = (64u) (8u) at;
      t64 = st.[:u64 at_64];
      buf.[:u64 off] = t64;
      at = newat;
      off += 8;
    }

  // leftovers...
  if (at < upto) {
    upto8 = upto;
    upto8 = (8ui) ((8u) upto8 & 0x07);
    at_64 = (64u) (8u) at;
    t64 = st.[at_64];
    off, buf = awrite_subu64(buf, off, t64, upto8);
  }

  at = upto;
  return at, off, buf;
}

inline fn __squeeze_incarray_ref
( reg mut ptr u8[LEN] buf
, reg mut ptr keccak1600_incstate st
) -> reg ptr keccak1600_incstate /* st */
   , reg ptr u8[LEN]             /* buf */
{
  reg u64 ststatus;
  reg ui64 off, len, r8_64;
  reg ui8 r8, at;
  reg ptr u64[25] stk;

  ststatus = st[25];
  r8, at = __r8_at(ststatus); // 0 < r8 < 200; r8 |% 8; 0 <= at <= r8

  if ( at == 0 ) {
    stk = st[0:25];
    () = #spill(st, r8, at, buf);
    stk = _keccakf1600_ref_(stk);
    () = #unspill(st, r8, at, buf);
    st[0:25] = stk;
  }

  off = 0;
  len = (64ui) (64u) (8u) at;
  len += LEN;

  r8_64 = (64ui) (64u) (8u) r8;
  while (r8_64 < len) {
    at, off, buf = _dump_incarray(buf, st, at, off, r8);
    stk = st[0:25];    
    () = #spill(st, r8, at, len, off, buf);
    stk = _keccakf1600_ref_(stk);
    () = #unspill(st, r8, at, len, off, buf);
    st[0:25] = stk;
    len -= r8_64;
    at = 0;
  }

  len = len;
  at, _, buf = _dump_incarray(buf, st, at, off, len);

  // if ( at == r8 ) at = 0; // avoidable because r8_at() returns 0<=at<r8
  st.[:u8 8*25] = (8u) at;

  return st, buf;
}




export fn test_ststatus
( reg mut ptr u8[3] status
, reg const ptr keccak1600_incstate st
) -> reg ptr u8[3]
{
  reg ui8 r8 at;
  reg u64 ststatus;
  ststatus = st[25];
  r8, at = __r8_at(ststatus);
  status[0] = (8u) r8;
  status[1] = (8u) at;
  status[2] = st.[:u8 8*25+2];
  return status;
}

export fn test_init
( reg mut ptr keccak1600_incstate st
, reg u8 r64
, reg u8 trailb
) -> reg ptr keccak1600_incstate
{
  r64 = r64;
  trailb = trailb;
  st = _init_incstate_ref(st, r64, trailb);
  st = st;
  return st;
}

export fn test_update_ref
( reg mut ptr keccak1600_incstate st
, reg const ptr u8[LEN] buf
) -> reg ptr keccak1600_incstate /* st */
{
  st = st;
  buf = buf;
  st = __update_incarray_ref(st, buf);
  st = st;
  return st;
}

export fn test_finish
( reg mut ptr keccak1600_incstate st
) -> reg ptr keccak1600_incstate /* st */
{
  st = __finish_incarray_ref(st);
  return st;
}

export fn test_squeeze_ref
( reg mut ptr u8[LEN] buf
, reg mut ptr keccak1600_incstate st
) -> reg ptr u8[LEN] /* buf */
   , reg ptr keccak1600_incstate /* st */
{
  st = st;
  buf = buf;
  st, buf = __squeeze_incarray_ref(buf, st);
  st = st;
  buf = buf;
  return buf, st;
}



/*
param int ASIZE = 20 * LEN;

export fn test_kF
( reg mut ptr keccak1600_incstate st
) -> reg ptr keccak1600_incstate /* st */
{
  st = _testF(st);
  return st;
}

export fn test_loop
( reg mut ptr u8[ASIZE] buf
) -> reg ptr u8[ASIZE] /* buf */
{
  reg ui64 i;
  stack keccak1600_updstate st;
  reg ptr u8[LEN] tbuf;
  st = __init_updarray_ref(st, 17); // R64=17 (r8=136, as in SHA3_256)
  i = 0;
  while (i < ASIZE) {
    tbuf = buf[i:LEN];
    () = #spill(i, buf);
    st = _update_updarray_ref(st, tbuf);
    () = #unspill(i, buf);
    i += LEN;
  }
  
  st = __finish_updarray_ref(st, 0x1F);
  i = 0;
  while (i < ASIZE) {
    tbuf = buf[i:LEN];
    () = #spill(i, buf);
    st, tbuf = _squeeze_updarray_ref(tbuf, st);
    () = #unspill(i, buf);
    buf[i:LEN] = tbuf;
    i += LEN;
  }
  return buf;
}




#[returnaddress="stack"]
fn _testF
( reg mut ptr keccak1600_updstate st
) -> reg ptr keccak1600_updstate /* st */
{
 reg ptr u64[25] state;
 state = st[0:25];
 () = #spill(st);
 state = _keccakf1600_ref_(state);
 () = #unspill(st);
 st[0:25] = state;
 return st;
}
 
*/
