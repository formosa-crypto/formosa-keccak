/**************************************************************************** 

   DEPENDENCIES:
   =============

  The loading of this file depends on the following context:

 1) "keccak1600.jinc"
 2) param int _ASIZE

*****************************************************************************/

require "../common/subreadwrite_ASIZE.jinc"

/*
   INCREMENTAL ARRAY ABSORB
   ========================
*/
#[safety =
   { requires = 0<= offset && 0<= _LEN && offset + _LEN <= _ASIZE && is_arr_init(buf,offset,_LEN) && is_arr_init(st,0,7*32),
   , requires = AT + _LEN + (_TRAILB != 0 ? 1 : 0) < 200  && 0 <= _TRAILB && _TRAILB < 256 && 0<=AT && AT < 200 
   , res = { final_st, final_AT, final_offset }
   , ensures = is_arr_init(final_st,0,25*8) && final_AT == AT + _LEN + (_TRAILB != 0 ? 1 : 0) && final_offset == offset + _LEN
   }
 ]
inline fn __addstate_avx2ref
( reg mut ptr u64[25] st
, inline int AT /* bytes (0 <= AT < 200) */
, reg const ptr u8[_ASIZE] buf
, reg ui64 offset
, inline int _LEN
, inline int _TRAILB
) -> reg ptr u64[25] /* st */
   , inline int      /* AT */
   , reg ui64        /* offset */
{
  inline int DELTA, AT8;
  reg ui64 at;
  reg u256 t256;
  reg u64 w;

  DELTA = 0;

  // fill first word...
  AT8 = AT;
  AT = 8*(AT/8);
  if ( AT8 != 0 ) {
    DELTA, _LEN, _TRAILB, AT8, w = __a_ilen_read_upto8_at(buf, offset, DELTA, _LEN, _TRAILB, AT, AT8);
    st[AT/8] ^= w;
    AT = AT8;
  }

  // add complete words
  offset += DELTA;
  at = 32*(AT/32);
  while ( at < 32*(AT/32 + _LEN/32) ) {
    t256 = buf.[:u256 offset];
    t256 ^= st.[:u256 at];
    offset += 32;
    st.[:u256 at] = t256;
    at += 32;
  }
  at = AT/8;
  while ( at < AT/8 + _LEN/8 ) {
    w = buf.[:u64 offset];
    offset += 8;
    st[at] ^= w;
    at += 1;
  }

  // add last word...
  AT += 8*(_LEN/8);
  _LEN = _LEN%8;
  if ( 0 < _LEN || _TRAILB%256!= 0 ) {
    //AT += _LEN+(_TRAILB%256!=0?1:0);
    DELTA, _LEN, _TRAILB, AT, w = __a_ilen_read_upto8_at(buf, offset, 0, _LEN, _TRAILB, AT, AT);
    st[at] ^= w;
    offset += DELTA;
  }

  return st, AT, offset;
}

#[safety =
{ requires = 0<=AT  && AT < _RATE8
   && 0 < _RATE8 && _RATE8 < 200
   && is_arr_init(buf,0,_ASIZE) && is_arr_init(st,0,25*8)
   && 0 <= _TRAILB && _TRAILB < 256,
   res = { final_st, final_AT },
   ensures = is_arr_init(final_st,0,25*8) && final_AT == (AT + _ASIZE) % _RATE8 + (_TRAILB != 0 ? 1 : 0)
}]
inline fn __absorb_avx2ref
( reg mut ptr u64[25] st
, inline int AT
, reg const ptr u8[_ASIZE] buf
, inline int _TRAILB /* closes state if !=0 (i.e. adds trailbyte and padding) */
, inline int _RATE8
) -> reg ptr u64[25] /* st */
   , inline int /* AT */
{
  reg ui64 offset, i;
  inline int ITERS, _LEN;

  offset = 0;
  _LEN = _ASIZE;  

  if ( AT+_LEN >= _RATE8 ) { // more than one block...
    st, _, offset = __addstate_avx2ref(st, AT, buf, offset, _RATE8-AT, 0);
    _LEN = _LEN - (_RATE8-AT);
    AT = 0;
    st = _keccakf1600_st25_avx2(st);
    ITERS = _LEN/_RATE8;
    i = 0;
    while ( i < ITERS ) {
      st, _, offset = __addstate_avx2ref(st, 0, buf, offset, _RATE8, 0);
      st = _keccakf1600_st25_avx2(st);
      i += 1;
    }
    _LEN = _LEN % _RATE8;
  }
  st, AT, _ = __addstate_avx2ref(st, AT, buf, offset, _LEN, _TRAILB);
  if (_TRAILB!=0) { st = __addratebit_ref(st, _RATE8); }

  return st, AT;
}


/*
   ONE-SHOT (FIXED-SIZE) MEMORY SQUEEZE
   ====================================
*/
#[safety =
   { requires = 0<= offset && 0<= _LEN && is_arr_init(st,0,25*8) && offset + _LEN <= _ASIZE && _LEN <= 200 && is_arr_init(buf,0,offset)
   , res = { final_buf, final_offset }
   , ensures = is_arr_init(final_buf,0,offset + _LEN)
   , ensures = final_offset == offset + _LEN
   }
 ]
inline fn __dumpstate_avx2ref
( reg mut ptr u8[_ASIZE] buf
, reg ui64 offset
, inline int _LEN
, reg const ptr u64[25] st
) -> reg ptr u8[_ASIZE] /* buf */
   , reg ui64 /* offset */
{ 
  reg ui64 i;
  reg u64 t;
  reg u256 t256;
  inline int DELTA;

  i = 0;
  while (i < _LEN/32) {
    t256 = st.[:u256 i];
    buf.[:u256 offset] = t256;
    offset += 32;
    i += 32;
  }
  i >>= 5;
  while (i < _LEN/8) {
    t = st[i];
    buf.[:u64 offset] = t;
    offset += 8;
    i += 1;
  }
  if (0 < _LEN%8) {
    t = st[i];
    buf, DELTA, _ = __a_ilen_write_upto8( buf, offset, 0, _LEN%8, t);
    offset += DELTA;
  }

  return buf, offset;
}

#[safety =
   { requires = is_arr_init(st,0,25*8) && 0 < _RATE8 && _RATE8 < 200
   , ensures = is_arr_init(buf,0,_ASIZE)
     && is_arr_init(st,0,25*8)
   }
 ]
inline fn __squeeze_avx2ref
( reg mut ptr u64[25] st
, reg mut ptr u8[_ASIZE] buf
, inline int _RATE8
) -> reg ptr u64[25] /* st */
   , reg ptr u8[_ASIZE] /* buf */
{
  reg ui64 offset, i;

  offset = 0;
  i = 0;
  while (i < _ASIZE/_RATE8) {
    st = _keccakf1600_st25_avx2(st);
    buf, offset = __dumpstate_avx2ref(buf, offset, _RATE8, st);
    i += 1;
  }
  if (0 < _ASIZE%_RATE8) {
    st = _keccakf1600_st25_avx2(st);
    buf, offset = __dumpstate_avx2ref(buf, offset, _ASIZE%_RATE8, st);
  }

  return st, buf;
}

