require "../common/keccakf1600_generic.jinc"

// C[x] = A[x,0] ^ A[x,1] ^ A[x,2] ^ A[x,3] ^ A[x,4]
inline fn keccakf1600_4x_theta_sum
( reg ptr u256[25] a
) -> reg u256[5]
{
  inline int x y;
  reg u256[5] c;

  // C[x] = A[x, 0]
  for x=0 to 5
  { c[x] = a[x + 0]; }

  // C[x] ^= A[x,1] ^ A[x,2] ^ A[x,3] ^ A[x,4]
  for y=1 to 5
  { for x=0 to 5
    { c[x] ^= a[x + y*5]; }
  }

  return c;
}

inline fn keccakf1600_4x_rol
( reg u256[5] a
, inline int x r
, reg u256 r8 r56
) -> reg u256[5]
/*safety*/ requires
  { is_arr_init(a,x*32,32) && 0<=x && x<5 }
/*safety*/ ensures
  { \all (k \in 0:160) (is_arr_init(result.0,k,1) == is_arr_init(a,k,1)) }
{
  reg u256 t;

  if(r == 8)
    { a[x] = #VPSHUFB_256(a[x], r8); }
  else {
    if(r == 56)
      { a[x] = #VPSHUFB_256(a[x], r56); }
    else
      { t     = #VPSLL_4u64(a[x], r);
	a[x]  = #VPSRL_4u64(a[x], 64 - r);
	a[x] |= t;
      }
  }

  return a; 
}

// D[x] = C[x-1] ^ ROT(C[x+1], 1) 
inline fn keccakf1600_4x_theta_rol
( reg u256[5] c
, reg u256 r8 r56
) -> reg u256[5]
{
  inline int x;
  reg u256[5] d;

  for x = 0 to 5
  { // D[x] = C[x + 1]
    d[x] = c[(x + 1) % 5];

    // D[x] = ROT(D[x], 1)
    d = keccakf1600_4x_rol(d, x, 1, r8, r56);

    // D[x] ^= C[x-1]
    d[x] ^= c[(x - 1 + 5) % 5];
  }

  return d;
}


// B[x] = ROT( (A[x',y'] ^ D[x']), r[x',y'] ) with (x',y') = M^-1 (x,y)
//
// M = (0 1)  M^-1 = (1 3)  x' = 1x + 3y
//     (2 3)         (1 0)  y' = 1x + 0y
//
inline fn keccakf1600_4x_rol_sum
( reg ptr u256[25] a
, reg u256[5] d
, inline int y
, reg u256 r8 r56
) -> reg u256[5]
/*safety*/ requires
 { is_arr_init(a,0,800) && is_arr_init(d,0,160) && 0<=y && y<5 }
/*safety*/ ensures
 { is_arr_init(a,0,800) && is_arr_init(d,0,160) && 0<=y && y<5 }
{
  inline int r x x_ y_;
  reg u256[5] b;

  for x = 0 to 5
  {
    x_ = (x + 3*y) % 5;
    y_ = x;
    r = keccakf1600_rhotates(x_, y_);

    // B[x] = A[x',y']
    b[x] = a[x_ + y_*5];

    // B[x] ^= D[x'];
    b[x] ^= d[x_];

    // B[x] = ROT( B[x], r[x',y'] );
    if(r != 0)
      { b = keccakf1600_4x_rol(b, x, r, r8, r56); }
  }

  return b;
}


// E[x, y] = B[x] ^ ( (!B[x+1]) & B[x+2] )
// -- when x and y are 0: E[0,0] ^= RC[i];
inline fn keccakf1600_4x_set_row
( reg ptr u256[25] e
, reg u256[5] b
, inline int y
) -> reg ptr u256[25]
/*safety*/ requires
 { is_arr_init(b,0,160) && 0 <= y && y<5 }
/*safety*/ ensures
 { \all (k \in 0:800)
  (is_arr_init(result.0,k,1)
  == (is_arr_init(e,k,1) || (y*5*32 <=k && k < (y + 1)*5*32)))
 }
{
  inline int x x1 x2;
  reg u256 t;

  for x=0 to 5
  { 
    x1 = (x + 1) % 5;
    x2 = (x + 2) % 5;

    t = #VPANDN_256(b[x1], b[x2]);

    t ^= b[x];
    e[x + y*5] = t;
  }

  return e;
}

inline fn __keccakf1600_4x_pround
( reg mut ptr u256[25] e
, reg const ptr u256[25]a
, reg u256 r8 r56
) -> reg ptr u256[25]
/*safety*/ requires
 { is_arr_init(a,0,800) }
/*safety*/ ensures
 { is_arr_init(result.0,0,800) }
{
  inline int y;
  reg u256[5] b c d;

  c = keccakf1600_4x_theta_sum(a);
  d = keccakf1600_4x_theta_rol(c, r8, r56);

  for y = 0 to 5
  { b = keccakf1600_4x_rol_sum(a, d, y, r8, r56);
    e = keccakf1600_4x_set_row(e, b, y);
  }

  return e;
}

export fn __keccakf1600_4x_pround_inlined
( reg mut ptr u256[25] e
, reg const ptr u256[25]a
, reg u256 r8 r56
) -> reg ptr u256[25]
{
  e = __keccakf1600_4x_pround(e, a, r8, r56);
  return e;
}

