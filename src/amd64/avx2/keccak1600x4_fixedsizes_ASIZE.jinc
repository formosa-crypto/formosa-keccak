/* DEPENDENCIES: */
//require "keccak1600x4_fixedsizes.jinc"
//param int ASIZE = 1001;
//param int RATE8 = 136;

require "../common/subreadwrite_ASIZE.jinc"


/*
   INCREMENTAL ARRAY BROADCAST ABSORB
   ==================================
*/

inline fn __addstate_bcast_avx2x4
( reg mut ptr keccakx4_state st
, inline int AT /* bytes (0 <= AT < 200) */
, reg const ptr u8[_ASIZE] buf
, reg ui64 offset
, inline int _LEN
, inline int _TRAILB
) -> reg ptr u256[25] /* st */
   , inline int /* AT */
   , reg ui64 /* offset */
/*
/* safety */ requires
{ 0 <= offset && 0 <= _LEN &&  0<=AT  && AT < 200 && offset + _LEN <= _ASIZE
  && AT + _LEN + (_TRAILB != 0 ? 1 : 0) < 200 
  && is_arr_init(buf,offset,_LEN) && is_arr_init(st,0,25*32)
}
/* safety */ requires {0 <= _TRAILB && _TRAILB < 256}
/* safety */ ensures
{ is_arr_init(result.0,0,25*32)
  && result.1 == AT + _LEN + (_TRAILB != 0 ? 1 : 0)
  && result.2 == offset + _LEN
}
*/
{
  inline int DELTA, AT8;
  reg ui64 at;
  reg u256 w;

  DELTA = 0;

  // fill first word...
  AT8 = AT;
  AT = 8*(AT/8);
  if ( AT8%8 != 0 ) {
    DELTA, _LEN, _TRAILB, AT8, w = __a_ilen_read_bcast_upto8_at(buf, offset, DELTA, _LEN, _TRAILB, AT, AT8);
    w ^= st[AT/8];
    st[AT/8] = w;
    AT = AT8;
  }

  // add complete words
  offset += DELTA;
  at = 32*(AT/8);
  while ( at < 32*(AT/8 + _LEN/8) ) {
    w = #VPBROADCAST_4u64(buf.[:u64 offset]);
    offset += 8;
    w ^= st.[:u256 at];
    st.[:u256 at] = w;
    at += 32;
  }

  // add last word...
  AT += 8*(_LEN/8);
  _LEN = _LEN%8;
  if ( 0 < _LEN || _TRAILB%256!= 0 ) {
    //AT += _LEN+(_TRAILB%256!=0?1:0);
    DELTA, _LEN, _TRAILB, AT, w = __a_ilen_read_bcast_upto8_at(buf, offset, 0, _LEN, _TRAILB, AT, AT);
    w ^= st.[:u256 at];
    st.[:u256 at] = w;
    offset += DELTA;
  }

  return st, AT, offset;
}

inline fn __absorb_bcast_avx2x4
( reg mut ptr u256[25] st
, inline int AT
, reg const ptr u8[_ASIZE] buf
, inline int _TRAILB /* closes state if !=0 (i.e. adds trailbyte and padding) */
, inline int _RATE8
) -> reg ptr u256[25] /* st */
   , inline int /* AT */
/*
/* safety */ requires {
 0 <= offset && 0 <= _LEN &&  0<=AT  && AT < _RATE8 && offset + _LEN <= _ASIZE
 && AT + _LEN + (_TRAILB != 0 ? 1 : 0) < 200 
 && 0 < _RATE8 && _RATE8 < 200 && is_arr_init(buf,offset,_LEN) && is_arr_init(st,0,25*32)
}
/* safety */ requires { 0 <= _TRAILB && _TRAILB < 256 }
/* safety */ ensures {
 is_arr_init(result.0,0,25*32)
 && result.1 == (AT + _LEN) % _RATE8 + (_TRAILB != 0 ? 1 : 0)
}
*/
{
  reg ui64 offset, i;
  inline int ITERS, _LEN;

  offset = 0;
  _LEN = _ASIZE;

  if ( AT+_LEN >= _RATE8 ) { // more than one block...
    st, _, offset = __addstate_bcast_avx2x4(st, AT, buf, offset, _RATE8-AT, 0);
    _LEN = _LEN - (_RATE8-AT);
    AT = 0;
    st = _keccakf1600_avx2x4(st);
    ITERS = _LEN/_RATE8;
    i = 0;
    while ( i < ITERS ) {
      st, _, offset = __addstate_bcast_avx2x4(st, 0, buf, offset, _RATE8, 0);
      st = _keccakf1600_avx2x4(st);
      i += 1;
    }
    _LEN = _LEN % _RATE8;
  }
  st, AT, _ = __addstate_bcast_avx2x4(st, AT, buf, offset, _LEN, _TRAILB);
  if (_TRAILB!=0) { st = __addratebit_avx2x4(st, _RATE8); }

  return st, AT;
}


/*
   INCREMENTAL (FIXED-SIZE) MEMORY 4-way ABSORB
   ============================================
*/

inline fn __addstate_avx2x4
( reg mut ptr u256[25] st
, inline int AT /* bytes (0 <= AT < 200) */
, reg const ptr u8[_ASIZE] buf0 buf1 buf2 buf3
, reg ui64 offset
, inline int _LEN
, inline int _TRAILB
) -> reg ptr u256[25] /* st */
   , inline int /* AT */
   , reg ui64 /* offset */
/*
/* safety */ requires {
 0 <= offset && 0 <= _LEN && 0<=AT && AT < 200
 && offset + _LEN <= _ASIZE && AT + _LEN + (_TRAILB != 0 ? 1 : 0) < 200
 && is_arr_init(buf0,offset,_LEN) && is_arr_init(buf1,offset,_LEN)
 && is_arr_init(buf2,offset,_LEN) && is_arr_init(buf3,offset,_LEN)
 && is_arr_init(st,0,25*32)
}
/* safety */ requires { 0 <= _TRAILB && _TRAILB < 256 }
/* safety */ ensures {
 is_arr_init(result.0,0,25*32)
 && result.1 == AT + _LEN + (_TRAILB != 0 ? 1 : 0)
 && result.2 == offset + _LEN
}
*/
{

  inline int DELTA, AT8;
  reg ui64 at;
  reg u64 t0, t1, t2, t3;

  DELTA = 0;

  // fill first word...
  AT8 = AT;
  AT = 8*(AT/8);
  if ( AT8%8 != 0 ) {
    _, _, _, _, t0 = __a_ilen_read_upto8_at(buf0, offset, DELTA, _LEN, _TRAILB, AT, AT8);
    st[:u64 4*(AT/8) + 0] ^= t0;
    _, _, _, _, t1 = __a_ilen_read_upto8_at(buf1, offset, DELTA, _LEN, _TRAILB, AT, AT8);
    st[:u64 4*(AT/8) + 1] ^= t1;
    _, _, _, _, t2 = __a_ilen_read_upto8_at(buf2, offset, DELTA, _LEN, _TRAILB, AT, AT8);
    st[:u64 4*(AT/8) + 2] ^= t2;
    DELTA, _LEN, _TRAILB, AT8, t3 = __a_ilen_read_upto8_at(buf3, offset, DELTA, _LEN, _TRAILB, AT, AT8);
    st[:u64 4*(AT/8) + 3] ^= t3;
    AT = AT8;
  }

  // add complete words
  offset += DELTA;
  at = 4*(AT/8);
  while ( at < 4*(AT/8) + 4*(_LEN/8) ) {
      t0 = buf0.[:u64 offset];
      st[:u64 at + 0] ^= t0;
      t1 = buf1.[:u64 offset];
      st[:u64 at + 1] ^= t1;
      t2 = buf2.[:u64 offset];
      st[:u64 at + 2] ^= t2;
      t3 = buf3.[:u64 offset];
      offset += 8;
      st[:u64 at + 3] ^= t3;
      at += 4;
  }

  // add last word...
  AT += 8*(_LEN/8);
  _LEN = _LEN%8;
  if ( 0 < _LEN || _TRAILB%256!= 0 ) {
    _, _, _, _, t0 = __a_ilen_read_upto8_at(buf0, offset, 0, _LEN, _TRAILB, AT, AT);
    st[:u64 at + 0] ^= t0;
    _, _, _, _, t1 = __a_ilen_read_upto8_at(buf1, offset, 0, _LEN, _TRAILB, AT, AT);
    st[:u64 at + 1] ^= t1;
    _, _, _, _, t2 = __a_ilen_read_upto8_at(buf2, offset, 0, _LEN, _TRAILB, AT, AT);
    st[:u64 at + 2] ^= t2;
    DELTA, _LEN, _TRAILB, AT, t3 = __a_ilen_read_upto8_at(buf3, offset, 0, _LEN, _TRAILB, AT, AT);
    st[:u64 at + 3] ^= t3;
    offset += DELTA;
  }

  return st, AT, offset;
}

inline fn __absorb_avx2x4
( reg mut ptr u256[25] st
, inline int AT
, reg const ptr u8[_ASIZE] buf0 buf1 buf2 buf3
, inline int _TRAILB /* closes state if !=0 (i.e. adds trailbyte and padding) */
, inline int _RATE8
) -> reg ptr u256[25] /* st */
   , inline int /* AT */
/*
requires{0 <= offset && 0 <= _LEN && 0<=AT && AT < _RATE8 && 0 < _RATE8 && _RATE8 < 200 &&
         offset + _LEN <= _ASIZE && AT + _LEN + (_TRAILB != 0 ? 1 : 0) < 200 &&
         is_arr_init(buf0,offset,_LEN) && is_arr_init(buf1,offset,_LEN) && 
         is_arr_init(buf2,offset,_LEN) && is_arr_init(buf3,offset,_LEN) && 
         is_arr_init(st,0,25*32)}
requires{0 <= _TRAILB && _TRAILB < 256}
ensures{is_arr_init(result.0,0,25*32)}
*/
{
  reg ui64 offset, i;
  inline int ITERS, _LEN;

  offset = 0;
  _LEN = _ASIZE;

  if ( AT+_LEN >= _RATE8 ) { // more than one block...
    st, _, offset = __addstate_avx2x4(st, AT, buf0, buf1, buf2, buf3, offset, _RATE8-AT, 0);
    _LEN = _LEN - (_RATE8-AT);
    AT = 0;
    st = _keccakf1600_avx2x4(st);
    ITERS = _LEN/_RATE8;
    i = 0;
    while ( i < ITERS ) {
      st, _, offset = __addstate_avx2x4(st, 0, buf0, buf1, buf2, buf3, offset, _RATE8, 0);
      st = _keccakf1600_avx2x4(st);
      i += 1;
    }
    _LEN = _LEN % _RATE8;
  }
  st, AT, _ = __addstate_avx2x4(st, AT, buf0, buf1, buf2, buf3, offset, _LEN, _TRAILB);
  if (_TRAILB!=0) { st = __addratebit_avx2x4(st, _RATE8); }

  return st, AT;
}

/*
   ONE-SHOT (FIXED-SIZE) MEMORY SQUEEZE
   ====================================
*/
inline fn __dumpstate_avx2x4
( reg mut ptr u8[_ASIZE] buf0 buf1 buf2 buf3
, reg ui64 offset
, inline int _LEN
, reg const ptr u256[25] st
) -> reg ptr u8[_ASIZE] /* buf0 */
   , reg ptr u8[_ASIZE] /* buf1 */
   , reg ptr u8[_ASIZE] /* buf2 */
   , reg ptr u8[_ASIZE] /* buf3 */
   , reg ui64 /* offset */
/*
requires{0 <= offset && 0 <= _LEN && is_arr_init(st,0,25*32) && offset + _LEN <= _ASIZE && _LEN <= 200}
ensures { \all (k \in 0:_ASIZE) (is_arr_init(result.0,k,1) == (is_arr_init(buf0,k,1) || (offset <= k && k< offset + _LEN)))}
ensures { \all (k \in 0:_ASIZE) (is_arr_init(result.1,k,1) == (is_arr_init(buf1,k,1) || (offset <= k && k< offset + _LEN)))}
ensures { \all (k \in 0:_ASIZE) (is_arr_init(result.2,k,1) == (is_arr_init(buf2,k,1) || (offset <= k && k< offset + _LEN)))}
ensures { \all (k \in 0:_ASIZE) (is_arr_init(result.3,k,1) == (is_arr_init(buf3,k,1) || (offset <= k && k< offset + _LEN)))}
ensures{ result.4 == offset + _LEN}
*/
{ 
  reg u256 x0, x1, x2, x3;
  reg ui64 i;
  reg u64 t0, t1, t2, t3;

  i = 0;

  while (i < 32*(_LEN/32)) {
    x0 = st.[:u256 4*i+0*32];
    x1 = st.[:u256 4*i+1*32];
    x2 = st.[:u256 4*i+2*32];
    x3 = st.[:u256 4*i+3*32];
    i += 32;
    x0, x1, x2, x3 = __4u64x4_u256x4(x0, x1, x2, x3);
    buf0.[:u256 offset] = x0;
    buf1.[:u256 offset] = x1;
    buf2.[:u256 offset] = x2;
    buf3.[:u256 offset] = x3;
    offset +=32;
  } // 0 32 (64) 
  while ( i < 8*(_LEN/8)) {
    t0 = st.[:u64 4*i+0*8];
    buf0.[:u64 offset] = t0;
    t1 = st.[:u64 4*i+1*8];
    buf1.[:u64 offset] = t1;
    t2 = st.[:u64 4*i+2*8];
    buf2.[:u64 offset] = t2;
    t3 = st.[:u64 4*i+3*8];
    buf3.[:u64 offset] = t3;
    i += 8;
    offset += 8;
  }
  if (0 < _LEN%8) {
    t0 = st.[:u64 4*i+0*8];
    buf0, _, _ = __a_ilen_write_upto8( buf0, offset, 0, _LEN%8, t0);
    t1 = st.[:u64 4*i+1*8];
    buf1, _, _ = __a_ilen_write_upto8( buf1, offset, 0, _LEN%8, t1);
    t2 = st.[:u64 4*i+2*8];
    buf2, _, _ = __a_ilen_write_upto8( buf2, offset, 0, _LEN%8, t2);
    t3 = st.[:u64 4*i+3*8];
    buf3, _, _ = __a_ilen_write_upto8( buf3, offset, 0, _LEN%8, t3);
    offset += _LEN%8;
  }

  return buf0, buf1, buf2, buf3, offset;
}

inline fn __squeeze_avx2x4
( reg mut ptr u256[25] st
, reg mut ptr u8[_ASIZE] buf0 buf1 buf2 buf3
, inline int _RATE8
) -> reg ptr u256[25]   /* st */
   , reg ptr u8[_ASIZE] /* buf0 */
   , reg ptr u8[_ASIZE] /* buf1 */
   , reg ptr u8[_ASIZE] /* buf2 */
   , reg ptr u8[_ASIZE] /* buf3 */
/*
requires{0 <= offset && 0 <= _LEN && is_arr_init(st,0,25*32) && offset + _LEN <= _ASIZE && 0 < _RATE8 && _RATE8 < 200 }
ensures { \all (k \in 0:_ASIZE) (is_arr_init(result.0,k,1) == (is_arr_init(buf0,k,1) || (offset <= k && k< offset + _LEN)))}
ensures { \all (k \in 0:_ASIZE) (is_arr_init(result.1,k,1) == (is_arr_init(buf1,k,1) || (offset <= k && k< offset + _LEN)))}
ensures { \all (k \in 0:_ASIZE) (is_arr_init(result.2,k,1) == (is_arr_init(buf2,k,1) || (offset <= k && k< offset + _LEN)))}
ensures { \all (k \in 0:_ASIZE) (is_arr_init(result.3,k,1) == (is_arr_init(buf3,k,1) || (offset <= k && k< offset + _LEN)))}
ensures{ is_arr_init(result.5,0,25*32)}
*/
{
  reg ui64 i, offset;
  inline int _LEN, ITERS, LO;

  offset = 0;
  _LEN = _ASIZE;
  ITERS = _LEN/_RATE8;
  LO = _LEN%_RATE8;

  if (0 < ITERS) {
    i = 0;
    while (i < ITERS) {
      st = _keccakf1600_avx2x4(st);
      buf0, buf1, buf2, buf3, offset
	= __dumpstate_avx2x4(buf0, buf1, buf2, buf3, offset, _RATE8, st);
      i += 1;
    }
  }
  if (0 < LO) {
    st = _keccakf1600_avx2x4(st);
    buf0, buf1, buf2, buf3, offset
      = __dumpstate_avx2x4(buf0, buf1, buf2, buf3, offset, LO, st);
  }

  return st, buf0, buf1, buf2, buf3;
}


