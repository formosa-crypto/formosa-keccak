/* IMPORTANT:
 This file expects to be "required" after defining the function '__ANDN_64',
 itself defined in either 'select_nobmi1_ref.jinc' or 'select_bmi1_ref.jinc'
*/

require "keccakf1600x4.jinc"
require "keccak1600.jinc"

type keccakx4_updstate = u64[4*25+1];

/**
 Last u64 word of keccak_updstate is filled with:
  - byte[0] - at_position (pre: 0 <= at <= 200)
  - byte[1] - r64-1, where r64 = 8*r8 (rate in bytes) -- (pre: 0 < r64 <= 25)
  - byte[2] - Trail Byte
*/


fn _init_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
, reg ui8 r64 // 9 <= r64 < 25 
, reg u8 trailb // 0 <= trailb < 256
) -> reg ptr keccakx4_updstate /* st */
{
  reg ui64 i;
  reg u64 status, t;
  reg u256 zero;

  zero = #set0_256();
  status = (64u) trailb;
  status <<= 8;
  r64 = (8ui) ((8u)r64 - 1);
  t = (64u) (8u) r64;
  status += t;
  status <<= 8;
  i = 0;
  while (i < 32*25) { st.[:u256 i] = zero; i += 32; }
  st[:u64 4*25] = status;

  return st;
}


/**
 When we read the update-data from the state (r8 and at-position), we guarantee
 that it is wellformed, that is:
  - rate in bytes (r8):  0 < r8 < 200  &&  r8 %| 8
  - at-position (at):  0 <= at < r8
 This would allow to establish safety independently of the given state.
*/
fn _ststatus_data_avx2x4
( reg u64 ststatus
) -> reg u64    /* trailb */
   , reg ui64  /* r8 ; 8 %| r8 /\ 0 < r8 <= 200  */
   , reg ui64  /* at  ; 0 <= at < r8 */
/* ensures:
    8 |% r8
    0 < r8 <= 200
    0 <= at < r8  */
{
 reg u64 trailb, r8, at, c_0, c_200;
 reg ui64 r8_ui, at_ui;

 at = ststatus;
 at &= 0xFF;
 ststatus >>= 8;
 r8 = ststatus;
 r8 &= 255; // 0 <= r8 < 256
 r8 += 1;   // 0 < r8 <= 256
 r8 <<= 3;  // 8 %| r8  /\  0 < r8 <= 2048
 c_200 = 200;
 r8 = c_200 if r8 > 200;  // 8 %| r8  /\  0 < r8 <= 200
 c_0 = 0;
 at = c_0 if r8 <= at;  // 0 <= at < r8
 ststatus >>= 8;
 ststatus &= 255;
 trailb = ststatus;

 r8_ui = (64ui)r8;
 at_ui = (64ui)at;
 return trailb, r8_ui, at_ui;
}

fn _finish_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
) -> reg ptr keccakx4_updstate /* st */
{
  reg u64 ststatus, trailb, rbit;
  reg ui64 at, r8;
  reg u8 t8;
  reg u128 t128;
  reg u256 t256;

  ststatus = st[:u64 4*25];
  trailb, r8, at = _ststatus_data_avx2x4(ststatus);
  // add trailbyte
  t8 = (8u) (64u) at;
  at >>= 3;
  at <<= 5;
  t8 = t8 & 0x07;
  t8 <<= 3;
  trailb <<= (t8 & 63);
  t128 = (128u) trailb;
  t256 = #VPBROADCAST_4u64(t128);
  t256 ^= st.[:u256 at];
  st.[:u256 at] = t256;
  // add ratebit
  rbit = 1;
  rbit <<= 63; // obs: 8 %| r8
  r8 -= 1;
  r8 >>= 3;    // r64
  r8 <<= 5;
  t128 = (128u) rbit;
  t256 = #VPBROADCAST_4u64(t128);
  t256 ^= st.[:u256 r8];
  st.[:u256 r8] = t256;
  st.[:u32 4*8*25] &= 0xFF00FF00; // clear trail-byte and at-position
  
  return st;
}


export fn ststatus_updstate_avx2x4
( reg mut ptr u8[3] status
, reg const ptr keccakx4_updstate st
) -> reg ptr u8[3]
{
  reg ui64 r8 at;
  reg u64 ststatus;
  ststatus = st[25];
  _, r8, at = _ststatus_data_avx2x4(ststatus);
  status[0] = (8u) (64u) r8;
  status[1] = (8u) (64u) at;
  status[2] = st.[:u8 8*25+2];
  return status;
}

export fn init_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
, reg ui8 r64
, reg u8 trailb
) -> reg ptr keccakx4_updstate
{
  st = st;
  r64 = r64;
  trailb = trailb;
  st = _init_updstate_avx2x4(st, r64, trailb);
  return st;
}

export fn finish_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
) -> reg ptr keccakx4_updstate /* st */
{
  st = st;
  st = _finish_updstate_avx2x4(st);
  return st;
}









/*
 *  REMARK: the remaining of this file is expected to be kept in sync. with its array version's
 *  counterpart ("keccak1600x4_updstate_ASIZE.jinc")
 *
 */





fn _add_m_bcast_updstate_avx2x4
( reg mut ptr keccakx4_state st
, reg ui64 at               // 0 <= at < 200
, reg ui64 buf // at+_ASIZE <= 200 (in fact, r8...)
, reg ui64 upto    // at <= upto <= 200 (in fact, r8...)
) -> reg ui64                 /* at */
   , reg ui64                 /* buf */
   , reg ptr keccakx4_state /* st */
{
  reg u8 sh;
  reg u64 t64, at8, upto8;
  reg u128 t128;
  reg u256 t256;
  reg ui64 off2, newat, len;

  at8 = (64u) at;
  at8 &= 0x07; // byte position in stword

  if (at8 != 0) { // needs to fill first word...
    len = upto;
    len -= at; // len = upto-at (bytes to process)
    at >>= 3; at <<= 3; // at = 8*(at/8) (start of stword)
    off2, t64 = __m_rlen_read_upto8(buf, len);
    len = len + (64ui)at; // bytes from the start of word
    sh = (8u) at8;
    sh <<= 3;   // bits to shift...
    t64 <<= (sh & 63);
    t128 = (128u) t64;
    t256 = #VPBROADCAST_4u64(t128);
    t256 ^= st.[:u256 4*at + 0];
    st.[:u256 4*at + 0] = t256;
    if (len >= 8) { // need to proccess more stwords...
      buf += 8;
      buf -= (64ui) at8; // off += (8-at8)
      at += 8;    // start of next stword
    } else { // this is the only affected stword
      buf = off2; // 
      at = upto;  // its done!
    }
  }

  // now: at%8==0 || at==upto
  newat = at;
  while
    { newat += 8; }
  ( newat <= upto )
    {
      t256 = #VPBROADCAST_4u64([:u64 buf]);
      t256 ^= st.[:u256 4*at];
      st.[:u256 4*at] = t256;
      at = newat;
      buf += 8;
    }

  // leftovers...
  if (at < upto) {
    upto8 = (64u) upto;
    upto8 &= 0x07;
    buf, t64 = __m_rlen_read_upto8(buf, off, (64ui) upto8);
    t128 = (128u) t64;
    t256 = #VPBROADCAST_4u64(t128);
    t256 ^= st.[:u256 4*at];
    st.[:u256 4*at] = t256;
  }
  
  at = upto;
  return at, buf, st;
}

fn _absorb_m_bcast_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
, reg ui64 buf
, reg ui64 len
) -> reg ptr keccakx4_updstate /* st */
{
  reg u64 ststatus;
  reg ui64 off, r8, at;
  reg ptr keccakx4_state stk;

  ststatus = st[:u64 4*25];
  _, r8, at = _ststatus_data_avx2x4(ststatus); // 0 < r8 < 200; r8 |% 8; 0 <= at <= r8
  stk = st[:u256 0:25];

  off = 0;
  len += at;
  while (r8 <= len) {
    at, off, stk = _add_m_bcast_updstate_avx2x4(stk, at, buf, off, r8);
    stk = _keccakf1600_avx2x4(stk);
    len -= r8;
    at = 0;
  }
  len = len;
  at, _, stk = _add_m_bcast_updstate_avx2x4(stk, at, buf, off, len);
  st[:u256 0:25] = stk;
  st.[:u8 32*25] = (8u) (64u) at;

  return st;
}

fn _add_m_updstate_avx2x4
( reg mut ptr keccakx4_state st
, reg ui64 at               // 0 <= at < 200
, reg ui64 buf0 buf1 buf2 buf3 // at+_ASIZE <= 200 (in fact, r8...)
, reg ui64 upto    // at <= upto <= 200 (in fact, r8...)
) -> reg ui64                 /* at */
   , reg ui64                 /* buf0 */
   , reg ui64                 /* buf1 */
   , reg ui64                 /* buf2 */
   , reg ui64                 /* buf3 */
   , reg ptr keccakx4_state /* st */
{
  reg u8 sh, shval;
  reg u64 t64, at8, upto8;
  reg ui64 off2, newat, len;

  at8 = (64u) at;
  at8 &= 0x07; // byte position in stword

  if (at8 != 0) { // needs to fill first word...
    len = upto;
    len -= at; // len = upto-at (bytes to process)
    at >>= 3; at <<= 3; // at = 8*(at/8) (start of stword)
    shval = (8u) at8;
    shval <<= 3;   // bits to shift...
    buf0, t64 = __m_rlen_read_upto8(buf0, len);
    sh = shval;
    t64 <<= (sh & 63);
    st.[:u64 4*at + 0 ] ^= t64;
    buf1, t64 = __m_rlen_read_upto8(buf1, len);
    sh = shval;
    t64 <<= (sh & 63);
    st.[:u64 4*at + 8 ] ^= t64;
    buf2, t64 = __m_rlen_read_upto8(buf2, len);
    sh = shval;
    t64 <<= (sh & 63);
    st.[:u64 4*at + 16] ^= t64;
    buf3, t64 = __m_rlen_read_upto8(buf3, len);
    sh = shval;
    t64 <<= (sh & 63);
    st.[:u64 4*at + 24] ^= t64;
    len = len + (64ui)at8; // bytes from the start of word
//at8=3; len=7 => len=10 (buf=+7)
    if (len >= 8) { // need to proccess more stwords...
      buf += 8;
      buf -= (64ui) at8; // off += (8-at8)
      at += 8;    // start of next stword
    } else { // this is the only affected stword
      buf = off2; // 
      at = upto;  // its done!
    }
  }

  // now: at%8==0 || at==upto
  newat = at;
  while
    { newat += 8; }
  ( newat <= upto )
    {
      t64 = buf0.[:u64 off];
      st.[:u64 4*at + 0 ] ^= t64;
      t64 = buf1.[:u64 off];
      st.[:u64 4*at + 8 ] ^= t64;
      t64 = buf2.[:u64 off];
      st.[:u64 4*at + 16] ^= t64;
      t64 = buf3.[:u64 off];
      st.[:u64 4*at + 24] ^= t64;
      at = newat;
      off += 8;
    }

  // leftovers...
  if (at < upto) {
    upto8 = (64u) upto;
    upto8 &= 0x07;
    _, t64 = __a_rlen_read_upto8(buf0, off, (64ui) upto8);
    st.[:u64 4*at + 0 ] ^= t64;
    _, t64 = __a_rlen_read_upto8(buf1, off, (64ui) upto8);
    st.[:u64 4*at + 8 ] ^= t64;
    _, t64 = __a_rlen_read_upto8(buf2, off, (64ui) upto8);
    st.[:u64 4*at + 16] ^= t64;
    off, t64 = __a_rlen_read_upto8(buf3, off, (64ui) upto8);
    st.[:u64 4*at + 24] ^= t64;
  }
  
  at = upto;
  return at, off, st;
}

fn _absorb_m_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
, reg ui64 buf0 buf1 buf2 buf3
, reg ui64 len
) -> reg ptr keccakx4_updstate /* st */
{
  reg u64 ststatus;
  reg ui64 off, r8, at;
  reg ptr keccakx4_state stk;

  ststatus = st[:u64 4*25];
  _, r8, at = _ststatus_data_avx2x4(ststatus); // 0 < r8 < 200; r8 |% 8; 0 <= at <= r8
  stk = st[:u256 0:25];
  () = #spill(st);

  off = 0;
  len += at;
  while (r8 <= len) {
    () = #spill(len);
    at, off, stk = _add_updstate_avx2x4(stk, at, buf0, buf1, buf2, buf3, off, r8);
    () = #unspill(len);
    stk = _keccakf1600_avx2x4(stk);
    len -= r8;
    at = 0;
  }
  len = len;
  at, _, stk = _add_updstate_avx2x4(stk, at, buf0, buf1, buf2, buf3, off, len);
  () = #unspill(st);
  st[:u256 0:25] = stk;
  st.[:u8 32*25] = (8u) (64u) at;

  return st;
}

fn _dump_m_updstate_avx2x4
( reg ui64 buf0 buf1 buf2 buf3
, reg const ptr keccakx4_state st
, reg ui64 at     // at+_ASIZE <= r8
, reg ui64 upto   // at <= upto <= r8
) -> reg ui64        /* at */
   , reg ui64        /* off */
   , reg ptr u8[_ASIZE] /* buf0 */
   , reg ptr u8[_ASIZE] /* buf1 */
   , reg ptr u8[_ASIZE] /* buf2 */
   , reg ptr u8[_ASIZE] /* buf3 */
{
  reg ui64 newat, off2, len;
  reg u64 t64, at8, upto8;
  reg u8 sh;

  at8 = (64u) at;
  at8 &= 0x07; // byte position in stword

  if (at8 != 0) { // needs to dump remainder of first word...
    len = upto;
    len -= at; // len = upto-at (bytes to process)
    at >>= 3; at <<= 3; // at = 8*(at/8) (start of stword)
    sh = (8u) at8;
    sh <<= 3;   // bits to shift...
    t64 = st.[:u64 4*at + 0 ];
    t64 >>= (sh & 63);
    buf0, _ = __a_rlen_write_upto8(buf0, off, t64, len);
    t64 = st.[:u64 4*at + 8 ];
    t64 >>= (sh & 63);
    buf1, _ = __a_rlen_write_upto8(buf1, off, t64, len);
    t64 = st.[:u64 4*at + 16];
    t64 >>= (sh & 63);
    buf2, _ = __a_rlen_write_upto8(buf2, off, t64, len);
    t64 = st.[:u64 4*at + 24];
    t64 >>= (sh & 63);
    buf3, off2 = __a_rlen_write_upto8(buf3, off, t64, len);
    len += (64ui) at8; // bytes from the start of word
    if (len >= 8) {  // need to proccess more stwords...
      off += 8;
      off -= (64ui) at8;
      at += 8;       // start of next stword
    } else {         // this is the only affected stword
      off = off2;
      at = upto;     // its done!
    }
  }

  // now: at%8==0 || at==upto
  newat = at;
  while
    { newat += 8; }
  ( newat <= upto )
    {
      t64 = st.[:u64 4*at + 0 ];
      buf0.[:u64 off] = t64;
      t64 = st.[:u64 4*at + 8 ];
      buf1.[:u64 off] = t64;
      t64 = st.[:u64 4*at + 16];
      buf2.[:u64 off] = t64;
      t64 = st.[:u64 4*at + 24];
      buf3.[:u64 off] = t64;
      at = newat;
      off += 8;
    }

  // leftovers...
  if (at < upto) {
    upto8 = (64u) upto;
    upto8 &= 0x07;
    t64 = st.[:u64 4*at + 0 ];
    buf0, _ = __a_rlen_write_upto8(buf0, off, t64, (64ui) upto8);
    t64 = st.[:u64 4*at + 8 ];
    buf1, _ = __a_rlen_write_upto8(buf1, off, t64, (64ui) upto8);
    t64 = st.[:u64 4*at + 16];
    buf2, _ = __a_rlen_write_upto8(buf2, off, t64, (64ui) upto8);
    t64 = st.[:u64 4*at + 24];
    buf3, off = __a_rlen_write_upto8(buf3, off, t64, (64ui) upto8);
  }

  at = upto;
  return at, off, buf0, buf1, buf2, buf3;
}

fn _squeeze_m_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
, reg ui64 buf0 buf1 buf2 buf3
, reg ui64 len
) -> reg ptr keccakx4_updstate /* st */
   , reg ptr u8[_ASIZE]        /* buf0 */
   , reg ptr u8[_ASIZE]        /* buf1 */
   , reg ptr u8[_ASIZE]        /* buf2 */
   , reg ptr u8[_ASIZE]        /* buf3 */
{
  reg u64 ststatus;
  reg ui64 off, r8, at;
  reg ptr keccakx4_state stk;

  ststatus = st[:u64 4*25];
  _, r8, at = _ststatus_data_avx2x4(ststatus); // 0 < r8 < 200; r8 |% 8; 0 <= at <= r8
  stk = st[:u256 0:25];

  if ( at == 0 ) {
    stk = _keccakf1600_avx2x4(stk);
  }

  off = 0;
  len += at;

  while (r8 < len) {
    at, off, buf0, buf1, buf2, buf3 = _dump_updstate_avx2x4(buf0, buf1, buf2, buf3, off, stk, at, r8);
    stk = _keccakf1600_avx2x4(stk);
    len -= r8;
    at = 0;
  }

  len = len;
  at, _, buf0, buf1, buf2, buf3 = _dump_updstate_avx2x4(buf0, buf1, buf2, buf3, off, stk, at, len);

  st[:u256 0:25] = stk;
  // if ( at == r8 ) at = 0; // avoidable because r8_at() returns 0<=at<r8
  st.[:u8 32*25] = (8u) (64u) at;

  return st, buf0, buf1, buf2, buf3;
}

export fn absorb_m_bcast_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
, reg ui64 buf
, reg ui64 len
) -> reg ptr keccakx4_updstate /* st */
{
  st = st;
  buf = buf;
  len = len;
  st = _absorb_bcast_updstate_avx2x4(st, buf, len);
  return st;
}

export fn absorb_m_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
, reg ui64 buf0 buf1 buf2 buf3
, reg ui64 len
) -> reg ptr keccakx4_updstate /* st */
{
  st = st;
  buf0 = buf0;
  buf1 = buf1;
  buf2 = buf2;
  buf3 = buf3;
  len = len;
  st = _absorb_updstate_avx2x4(st, buf0, buf1, buf2, buf3, len);
  return st;
}

export fn squeeze_m_updstate_avx2x4
( reg mut ptr keccakx4_updstate st
, reg ui64 buf0 buf1 buf2 buf3
, reg ui64 len
) -> reg ptr keccakx4_updstate /* st */
   , reg ptr u8[_ASIZE] /* buf0 */
   , reg ptr u8[_ASIZE] /* buf1 */
   , reg ptr u8[_ASIZE] /* buf2 */
   , reg ptr u8[_ASIZE] /* buf3 */
{
  st = st;
  buf0 = buf0;
  buf1 = buf1;
  buf2 = buf2;
  buf3 = buf3;
  st, buf0, buf1, buf2, buf3 = _squeeze_updstate_avx2x4(st, buf0, buf1, buf2, buf3, len);
  return st, buf0, buf1, buf2, buf3;
}
