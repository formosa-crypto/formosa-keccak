require "keccak1600_generic.jinc"

/*
 *  REMARK: this file is expected to be kept in sync. with the array version's
 *  counterpart ("subreadwrite_ASIZE.jinc")
 *
 */



/**
    READ A FIXED NUMBER OF BYTES FROM MEMORY INTO A WORD
**/
#[safety =
   { requires = is_mem_init((64u) buf,max(LEN,8 - (AT-CUR))) && 0<=LEN
     && 0 <= TRAIL && TRAIL < 256
   , ensures =  (CUR <= AT && AT < CUR + 8) ?
       ( result.0 == buf + max(0,min(LEN,8 - (AT-CUR)))
     && result.1 == LEN - max(0,min(LEN,8- (AT-CUR)))
     && result.2 == (8 <=s AT-CUR + LEN ? TRAIL : 0)
     && result.3 == CUR + max(0,min(AT-CUR + LEN,8) + (8 <=s AT-CUR + LEN || TRAIL==0 ? 0 : 1)))
     : (result.0 == buf
      && result.1 == LEN
      && result.2 == TRAIL
      && result.3 == AT)
   }
 ]
inline fn __m_ilen_read_upto8_at
( reg ui64 buf
, inline int LEN
, inline int TRAIL
, inline int CUR
, inline int AT
) -> reg ui64   /* buf */
   , inline int /* LEN */
   , inline int /* TRAIL */
   , inline int /* AT */
   , reg u64    /* w */
{
  reg u64 w, t16, t8;
  inline int AT8;

  if ( AT < CUR || CUR+8 <= AT || LEN==0 && TRAIL==0 ) { // nothing to be done...
    w = 0;
  } else {
    AT8 = AT-CUR;
    if (8 <= LEN) {
      w = [:u64 (64u) buf];
      w = __SHLQ(w, AT8);
      buf += 8-AT8;
      LEN -= 8-AT8;
      AT8 = 8; 
    } else {
      if (4 <= LEN) {
	w = (64u) [:u32 (64u) buf];
	w = __SHLQ(w, AT8);
	buf += (4+AT8 >= 8 ? 8-AT8 : 4);
	LEN -= (4+AT8 >= 8 ? 8-AT8 : 4);
	AT8 = (4+AT8 >= 8 ? 8 : 4+AT8); // AT8==8: finished!
      } else {
	w = 0;
      }
      if (AT8 < 8 && 2 <= LEN) {
	t16 = (64u) [:u16 (64u) buf];
	buf += (2+AT8 >= 8 ? 8-AT8 : 2);
	LEN -= (2+AT8 >= 8 ? 8-AT8 : 2);
	t16 = __SHLQ(t16, AT8);
	w |= t16;
	AT8 = (2+AT8 >= 8 ? 8 : 2+AT8);
      }
      if (AT8 < 8) {
	if ( 1 <= LEN ) {
	  t8 = (64u) [:u8 (64u) buf];
	  t8 |= 256*(TRAIL%256);
	  buf += 1;
	  LEN -= 1;
	  t8 = __SHLQ(t8, AT8);
	  w |= t8;
	  AT8 += 1;
	  if (AT8 < 8 && TRAIL%256 != 0) {
	    AT8 += 1;
	    TRAIL = 0;
	  }
	} else if ( TRAIL%256 != 0) {
	  t8 = TRAIL%256;
	  t8 = __SHLQ(t8, AT8);
	  w |= t8;
	  TRAIL = 0;
	  AT8 += 1;
	}
      }
    }
    AT = CUR + AT8;
  }
  return buf, LEN, TRAIL, AT, w; 
}

#[safety =
   { requires = is_mem_init((64u) buf,max(LEN,16 - (AT-CUR))) && 0<=LEN
     && 0 <= TRAIL && TRAIL < 256
   , ensures =  (CUR <= AT && AT < CUR + 16) ?
       ( result.0 == buf + max(0,min(LEN,16 - (AT-CUR)))
     && result.1 == LEN - max(0,min(LEN,16- (AT-CUR)))
     && result.2 == (16 <=s AT-CUR + LEN ? TRAIL : 0)
     && result.3 == CUR + max(0,min(AT-CUR + LEN,16) + (16 <=s AT-CUR + LEN || TRAIL==0 ? 0 : 1)))
     : (result.0 == buf
      && result.1 == LEN
      && result.2 == TRAIL
      && result.3 == AT)
   }
 ]
inline fn __m_ilen_read_upto16_at
( reg ui64 buf
, inline int LEN
, inline int TRAIL
, inline int CUR
, inline int AT
) -> reg ui64   /* buf */
   , inline int /* LEN */
   , inline int /* TRAIL */
   , inline int /* AT */
   , reg u128    /* w */
{
  reg u64 t64_0, t64_1;
  reg u128 w;
  inline int AT16;

  if ( AT < CUR || CUR+16 <= AT || LEN==0 && TRAIL==0 ) { // nothing to be done...
    w = #set0_128();
  } else {
    AT16 = AT-CUR;
    if ( 16 <= LEN ) {
      w = [:u128 (64u) buf];
      w = __SHLDQ(w, AT16);
      buf += 16-AT16;
      LEN -= 16-AT16;
      AT16 = 16;
    } else if ( 8 <= AT16 ) {
      w = #set0_128();
      buf, LEN, TRAIL, AT16, t64_1 = __m_ilen_read_upto8_at(buf, LEN, TRAIL, 8, AT16);
      w = #VPINSR_2u64(w, t64_1, 1); 
    } else {
      buf, LEN, TRAIL, AT16, t64_0 = __m_ilen_read_upto8_at(buf, LEN, TRAIL, 0, AT16);
      w = (128u) t64_0;
      buf, LEN, TRAIL, AT16, t64_1 = __m_ilen_read_upto8_at(buf, LEN, TRAIL, 8, AT16);
      w = #VPINSR_2u64(w, t64_1, 1); 
    }
    AT = CUR+AT16;
  }
  return buf, LEN, TRAIL, AT, w; 
}  

#[safety =
   { requires = is_mem_init((64u) buf,max(LEN,32 - (AT-CUR))) && 0<=LEN
     && 0 <= TRAIL && TRAIL < 256
   , ensures =  (CUR <= AT && AT < CUR + 32) ?
       ( result.0 == buf + max(0,min(LEN,32 - (AT-CUR)))
     && result.1 == LEN - max(0,min(LEN,32- (AT-CUR)))
     && result.2 == (32 <=s AT-CUR + LEN ? TRAIL : 0)
     && result.3 == CUR + max(0,min(AT-CUR + LEN,32) + (32 <=s AT-CUR + LEN || TRAIL==0 ? 0 : 1)))
     : (result.0 == buf
      && result.1 == LEN
      && result.2 == TRAIL
      && result.3 == AT)
   }
 ]
inline fn __m_ilen_read_upto32_at
( reg ui64 buf
, inline int LEN
, inline int TRAIL
, inline int CUR
, inline int AT
) -> reg ui64   /* buf */
   , inline int /* LEN */
   , inline int /* TRAIL */
   , inline int /* AT */
   , reg u256    /* w */
{
  reg u128 t128_0, t128_1;
  reg u256 w;
  inline int AT32;

  if ( AT < CUR || CUR+32 <= AT || LEN==0 && TRAIL==0) { // nothing to be done...
    w = #set0_256();
  } else {
    AT32 = AT-CUR;
    if ( AT32==0 && 32 <= LEN ) {
      w = [:u256 (64u) buf];
      AT32 += 32;
      buf += 32;
      LEN -= 32;
    } else if ( 16 <= AT32 ) {
      w = #set0_256();
      buf, LEN, TRAIL, AT32, t128_1 = __m_ilen_read_upto16_at(buf, LEN, TRAIL, 16, AT32);
      w = #VINSERTI128(w, t128_1, 1); 
    } else {
      buf, LEN, TRAIL, AT32, t128_0 = __m_ilen_read_upto16_at(buf, LEN, TRAIL,  0, AT32);
      buf, LEN, TRAIL, AT32, t128_1 = __m_ilen_read_upto16_at(buf, LEN, TRAIL, 16, AT32);
      w = (2u128)[t128_1, t128_0];
    }
    AT = CUR+AT32;
  }
  return buf, LEN, TRAIL, AT, w; 
}  

#[safety =
   { requires = is_mem_init((64u) buf,max(LEN,8 - (AT-CUR))) && 0<=LEN
     && 0 <= TRAIL && TRAIL < 256
   , ensures =  (CUR <= AT && AT < CUR + 8) ?
       ( result.0 == buf + max(0,min(LEN,8 - (AT-CUR)))
     && result.1 == LEN - max(0,min(LEN,8- (AT-CUR)))
     && result.2 == (8 <=s AT-CUR + LEN ? TRAIL : 0)
     && result.3 == CUR + max(0,min(AT-CUR + LEN,8) + (8 <=s AT-CUR + LEN || TRAIL==0 ? 0 : 1)))
     : (result.0 == buf
      && result.1 == LEN
      && result.2 == TRAIL
      && result.3 == AT)
   }
 ]
inline fn __m_ilen_read_bcast_upto8_at
( reg ui64 buf
, inline int LEN
, inline int TRAIL
, inline int CUR
, inline int AT
) -> reg ui64   /* buf */
   , inline int /* LEN */
   , inline int /* TRAIL */
   , inline int /* AT */
   , reg u256   /* w */
{
  reg u64 w;
  reg u128 t128;
  reg u256 w256;
  inline int AT8;

  if ( AT < CUR || CUR+8 <= AT || LEN==0 && TRAIL==0 ) { // nothing to be done...
    w256 = #set0_256();
  } else {
    if (8 <= LEN) {
      AT8 = AT-CUR;
      w256 = #VPBROADCAST_4u64([:u64 (64u) buf]);
      w256 = __SHLQ_256(w256, AT8);
      buf += 8-AT8;
      LEN -= 8-AT8;
      AT = CUR + 8;
    } else {
      AT8 = AT-CUR;
      buf, LEN, TRAIL, AT, w = __m_ilen_read_upto8_at(buf, LEN, TRAIL, CUR, AT);
      t128 = (128u) w;
      w256 = #VPBROADCAST_4u64(t128);
      w256 = __SHLQ_256(w256, AT8);
    }
  }
  return buf, LEN, TRAIL, AT, w256; 
}

/**
    WRITE A FIXED NUMBER OF BYTES FROM MEMORY INTO A WORD
**/

// __awrite_subu64
#[safety =
   { requires = is_mem_init((64u) buf,min(LEN,8))
   , ensures = result.0 == buf + max(0,min(LEN,8))
     && result.1 == LEN - max(0,min(LEN,8))
   }
 ]
inline fn __m_ilen_write_upto8
( reg ui64 buf
, inline int LEN
, reg u64 w
) -> reg ui64 /* buf */
   , inline int /* LEN */
{
  if (0 < LEN) {
    if (8 <=s LEN) {
      [:u64 (64u) buf] = w;
      buf += 8;
      LEN -= 8;
    } else {
      if (4 <=s LEN) {
        [:u32 (64u) buf] = (32u) w;
	w >>= 32;
        buf += 4;
        LEN -= 4;
      }
      if (2 <=s LEN) {
        [:u16 (64u) buf] = (16u) w;
	w >>= 16;
        buf += 2;
        LEN -= 2;
      }
      if (1 <=s LEN) {
        [:u8 (64u) buf] = (8u) w;
        buf += 1;
        LEN -= 1;
      }
    }
  }
  return buf, LEN; 
}

// __awrite_subu128
#[safety =
   { requires = is_mem_init((64u) buf,min(LEN,16))
   , ensures = result.0 == buf + max(0,min(LEN,16))
     && result.1 == LEN - max(0,min(LEN,16))
   }
 ]
inline fn __m_ilen_write_upto16
( reg ui64 buf
, inline int LEN
, reg u128 w
) -> reg ui64     /* buf */
   , inline int   /* LEN */
{
  reg u64 t64;
  if (0 < LEN) {
    if (16 <=s LEN) {
      [:u128 (64u) buf] = w;
      buf += 16;
      LEN -= 16;
    } else {
      if (8 <=s LEN) {
        [:u64 (64u) buf] = #MOVV(w);
        buf += 8;
        LEN -= 8;
        w = #VPUNPCKH_2u64(w, w);
      }
      t64 = (64u) w;
      buf, LEN = __m_ilen_write_upto8(buf, LEN, t64);
    }
  }
  return buf, LEN;
}

// __awrite_subu256
#[safety =
   { requires = is_mem_init((64u) buf,min(LEN,32))
   , ensures = result.0 == buf + max(0,min(LEN,32))
     && result.1 == LEN - max(0,min(LEN,32))
   }
 ]
inline fn __m_ilen_write_upto32
( reg ui64 buf
, inline int LEN
, reg u256 w
) -> reg ui64   /* buf */
   , inline int /* LEN */
{
  reg u128 t128;
  if (0 < LEN) {
    if (32 <= LEN) {
      [:u256 (64u) buf] = w;
      buf += 32;
      LEN -= 32;
    } else {
      t128 = (128u) w;
      if (16 <= LEN) {
        [:u128 (64u) buf] = t128;
        buf += 16;
        LEN -= 16;
        t128 = #VEXTRACTI128(w, 1);
      }
      buf, LEN = __m_ilen_write_upto16(buf, LEN, t128);
    }
  }
  return buf, LEN;
}


/**
    READ A VARIABLE NUMBER OF BYTES FROM MEMORY INTO A WORD
**/
#[safety =
   { requires = is_mem_init((64u) buf,min(len,8))
   , ensures = result.0 == buf + min(len,8)
   }
 ]
inline fn __m_rlen_read_upto8
( reg ui64 buf
, reg ui64 len // off + len <= ASIZE
) -> reg ui64 /* buf */
   , reg u64  /* data */
{
  reg u64 w, x;
  reg u8 sh;
  reg bool zf;

  if (len >= 8) {
    w = [:u64 (64u) buf];
    buf += 8;
  } else {
    _, _, _, _, zf = #TEST((64u)len, 4);
    if (!zf) {
      w = (64u) [:u32 (64u) buf];
      buf += 4;
      sh = 32;
    } else {
      w = 0;
      sh = 0;
    }
    _, _, _, _, zf = #TEST((64u)len, 2);
    if (!zf) {
      x = (64u) [:u16 (64u) buf];
      x <<= (sh & 63);
      w += x;
      buf += 2;
      sh += 16;
    }
    _, _, _, _, zf = #TEST((64u)len, 1);
    if (!zf) {
      x = (64u) [:u8 (64u) buf];
      x <<= (sh & 63);
      w += x;
      buf += 1;
    }
  }
  return buf, w;
}


/**
    WRITE A VARIABLE NUMBER OF BYTES FROM AN ARRAY INTO A WORD
**/
#[safety =
   { requires = is_mem_init((64u) buf,min(len,8))
   , ensures = result.0 == buf + max(0,min(len,8))
   }
 ]
inline fn __m_rlen_write_upto8
( reg ui64 buf
, reg u64 data
, reg ui64 len // off + len <= ASIZE
) -> reg ui64   /* buf */
{
  reg bool zf;

  if (len >= 8) {
    [:u64 (64u) buf] = data;
    buf += 8;
  } else {
    _, _, _, _, zf = #TEST((64u)len, 4);
    if (!zf) {
      [:u32 (64u) buf] = (32u) data;
      buf += 4;
      data >>= 32;
    }
    _, _, _, _, zf = #TEST((64u)len, 2);
    if (!zf) {
      [:u16 (64u) buf] = (16u) data;
      buf += 2;
      data >>= 16;
    }
    _, _, _, _, zf = #TEST((64u)len, 1);
    if (!zf) {
      [:u8 (64u) buf] = (8u) data;
      buf += 1;
    }
  }
  return buf;
}






